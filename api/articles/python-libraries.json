{"title":"Python常用数据处理库概览","uid":"d18fcd6dc1394e0e934c5a6ec63149f0","slug":"python-libraries","date":"2025-08-14T16:00:00.000Z","updated":"2025-08-19T13:05:44.307Z","comments":true,"path":"api/articles/python-libraries.json","keywords":"blog, technology, programming","cover":"images/7.png","content":"<h2 id=\"引言\">引言</h2>\r\n<p>在数据科学、数据工程和数据分析领域，<strong>数据处理</strong>是必不可少的基础环节。业界常说数据科学家将大部分时间花在整理清洗数据上，有经验的分析师都深知这一点：整个数据分析过程中数据清洗往往占据了约\r\n80%\r\n的时间。数据质量直接影响后续的分析、模型训练和可视化结果，因此掌握高效的数据处理工具至关重要。本篇文章将介绍几款主流的\r\nPython\r\n数据处理库，它们在提升数据处理效率和质量方面扮演着重要角色，并通过简单示例演示其典型用法。</p>\r\n<h2 id=\"numpy高性能数值计算基础库\">NumPy：高性能数值计算基础库</h2>\r\n<p>NumPy（Numerical Python）是 Python\r\n科学计算领域最基本的底层库之一。它提供了高效的多维数组（ndarray）数据结构以及对数组进行快速运算的函数，是许多高级数据处理库（如\r\nPandas、Scikit-learn 等）的<strong>基础</strong>。NumPy\r\n用C语言实现底层算法，能够将繁重的数学运算卸载到底层以提高性能，对于需要对大规模数值数据进行向量化计算的场景非常适合。</p>\r\n<p><strong>主要功能和特点：</strong></p>\r\n<ul>\r\n<li><strong>N维数组对象：</strong>\r\n提供功能强大的多维数组（矩阵）类型，支持高效的元素级运算和切片索引。通过向量化操作，NumPy\r\n数组运算比纯 Python 循环快得多。<br />\r\n</li>\r\n<li><strong>广播机制：</strong>\r\n支持不同形状数组之间的算术运算，会自动地将较小的数组扩展以匹配较大数组的形状，方便进行批量运算。<br />\r\n</li>\r\n<li><strong>丰富的数值函数库：</strong>\r\n提供常用的线性代数运算、傅里叶变换、随机数生成等功能。这些函数大多针对数组进行了优化实现。<br />\r\n</li>\r\n<li><strong>与低级语言集成：</strong>\r\n提供与C/C++、Fortran语言的集成接口，可将现有高性能代码与 NumPy\r\n进行结合。</li>\r\n</ul>\r\n<p><strong>简单示例：</strong> 下面的示例创建一个 NumPy\r\n数组并进行基本运算，包括逐元素乘法和矩阵乘法。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建一个一维数组</span></span><br><span class=\"line\">a = np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a * <span class=\"number\">2</span>)         <span class=\"comment\"># 输出: [2 4 6 8]，数组每个元素乘以2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建二维数组（矩阵）并计算矩阵乘积</span></span><br><span class=\"line\">A = np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>],</span><br><span class=\"line\">              [<span class=\"number\">3</span>, <span class=\"number\">4</span>]])</span><br><span class=\"line\">B = np.array([[<span class=\"number\">5</span>, <span class=\"number\">6</span>],</span><br><span class=\"line\">              [<span class=\"number\">7</span>, <span class=\"number\">8</span>]])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(A.dot(B))      <span class=\"comment\"># 矩阵乘法结果: [[19 22]</span></span><br><span class=\"line\">                     <span class=\"comment\">#               [43 50]]</span></span><br></pre></td></tr></table></figure>\r\n<p>上述代码展示了 NumPy 数组的基本操作。利用\r\nNumPy，用户可以方便地进行大规模数值计算，例如对整个数组执行算术运算、线性代数计算等，而无需编写显式的Python循环。</p>\r\n<h2 id=\"pandas结构化数据处理与分析\">Pandas：结构化数据处理与分析</h2>\r\n<p>Pandas 是基于 NumPy\r\n的高级数据处理库，被广泛用于<strong>结构化数据</strong>（如表格、关系型数据）的清洗、操作与分析。正如其官网所描述，<em>“pandas\r\n是一个快速、强大、灵活且易用的开源数据分析与操作工具，构建于 Python\r\n编程语言之上”</em>。Pandas 提供了 DataFrame 和 Series\r\n两种主要数据结构：DataFrame 可理解为带行列索引的表格数据，Series\r\n可理解为一维带索引的数组。借助 Pandas，我们可以方便地读取\r\nCSV、Excel、SQL\r\n等数据源，对数据进行过滤、聚合、透视等操作，并辅以时间序列处理、缺失值填补等功能。</p>\r\n<p><strong>主要功能和特点：</strong></p>\r\n<ul>\r\n<li><strong>直观的数据结构：</strong> 提供 DataFrame（二维表格）和\r\nSeries（一维序列）数据结构，带有行列索引，方便按标签访问数据。<br />\r\n</li>\r\n<li><strong>丰富的数据读取与存储接口：</strong> 支持读取\r\nCSV、JSON、Excel、SQL\r\n数据库等多种格式的数据文件，并能将处理结果方便地输出为常用格式。<br />\r\n</li>\r\n<li><strong>强大的数据操作功能：</strong>\r\n提供基于索引的高效数据选取、过滤筛选，能方便地按照条件查询数据子集。内置大量方法用于数据聚合、分组计算（groupby）、透视表和重塑数据等。<br />\r\n</li>\r\n<li><strong>缺失值处理与数据清洗：</strong>\r\n内置处理缺失数据的方法（如填充填补 <code>fillna</code>、丢弃缺失值\r\n<code>dropna</code>），以及字符串处理、日期时间类型转换等工具，帮助用户清洗“脏”数据。<br />\r\n</li>\r\n<li><strong>与其他库集成：</strong> Pandas 对接 Matplotlib\r\n实现快速绘图，很多机器学习库也支持直接输入 Pandas\r\n数据结构。例如，Statsmodels 和 Scikit-learn 等都可以接受 DataFrame\r\n作为输入。</li>\r\n</ul>\r\n<p><strong>简单示例：</strong> 下面示例演示如何使用 Pandas\r\n加载数据、筛选数据以及计算基本统计量。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构造一个简单的 DataFrame</span></span><br><span class=\"line\">data = &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;Name&quot;</span>: [<span class=\"string\">&quot;Alice&quot;</span>, <span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Cathy&quot;</span>, <span class=\"string\">&quot;Dave&quot;</span>],</span><br><span class=\"line\">    <span class=\"string\">&quot;Age&quot;</span>:  [<span class=\"number\">24</span>, <span class=\"number\">27</span>, <span class=\"number\">22</span>, <span class=\"number\">32</span>],</span><br><span class=\"line\">    <span class=\"string\">&quot;City&quot;</span>: [<span class=\"string\">&quot;New York&quot;</span>, <span class=\"string\">&quot;Paris&quot;</span>, <span class=\"string\">&quot;London&quot;</span>, <span class=\"string\">&quot;New York&quot;</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">df = pd.DataFrame(data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 筛选出 Age 大于 25 的行</span></span><br><span class=\"line\">adults = df[df[<span class=\"string\">&quot;Age&quot;</span>] &gt; <span class=\"number\">25</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(adults)</span><br><span class=\"line\"><span class=\"comment\"># 输出:</span></span><br><span class=\"line\"><span class=\"comment\">#     Name  Age    City</span></span><br><span class=\"line\"><span class=\"comment\"># 1    Bob   27   Paris</span></span><br><span class=\"line\"><span class=\"comment\"># 3   Dave   32  New York</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 计算 Age 列的基本统计信息</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df[<span class=\"string\">&quot;Age&quot;</span>].mean())   <span class=\"comment\"># 平均年龄: 26.25</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(df[<span class=\"string\">&quot;Age&quot;</span>].<span class=\"built_in\">max</span>())    <span class=\"comment\"># 最大年龄: 32</span></span><br></pre></td></tr></table></figure>\r\n<p>在这个示例中，我们创建了一个\r\nDataFrame，然后按条件筛选出年龄大于25的记录，并计算年龄的平均值和最大值。Pandas\r\n提供的丰富功能让类似的<strong>数据清洗与分析任务</strong>变得简洁高效。</p>\r\n<h2 id=\"数据可视化matplotlib-与-seaborn\">数据可视化：Matplotlib 与\r\nSeaborn</h2>\r\n<p>数据处理的一个重要环节是将数据<strong>可视化</strong>，以便更直观地洞察数据特征和模式。Python\r\n生态中有两大常用可视化库：Matplotlib 和 Seaborn。Matplotlib\r\n是底层功能非常完备的绘图库，而 Seaborn 则基于 Matplotlib\r\n提供更高级抽象，使绘制<strong>统计图表</strong>更加简洁美观。它们经常配合使用：Matplotlib\r\n提供灵活的底层接口，Seaborn\r\n则简化了常见绘图操作并提供美观的默认样式。</p>\r\n<h3 id=\"matplotlib强大的绘图功能\">Matplotlib：强大的绘图功能</h3>\r\n<p>Matplotlib 是 Python\r\n中历史悠久且功能非常全面的绘图库。它能够创建静态、动画和交互式的各种图形。无论是简单的折线图、散点图，还是复杂的多子图布局、3D\r\n图形，Matplotlib 几乎都能胜任。它以类似 MATLAB\r\n的方式工作，提供<strong>状态机接口</strong>（<code>pyplot</code>\r\n模块）用于快速绘图，也提供面向对象的接口方便更精细的控制。Matplotlib\r\n的优势在于<strong>自定义能力强</strong>：用户可以自定义图表的几乎所有元素（颜色、样式、注释、刻度等），以生成出版级别的图形。</p>\r\n<p><strong>主要功能特色：</strong></p>\r\n<ul>\r\n<li><strong>多样的图表类型：</strong>\r\n支持折线图、柱状图、饼图、直方图、散点图、箱线图、热力图等常见图表类型，以及3D绘图、等高线图等高级图形。<br />\r\n</li>\r\n<li><strong>丰富的自定义选项：</strong>\r\n可以自由调整图表的标题、坐标轴标签、刻度、图例、颜色样式等元素，满足复杂的可视化需求。<br />\r\n</li>\r\n<li><strong>交互和输出：</strong>\r\n支持将绘图输出为多种格式（PNG、PDF、SVG等），并能与 Jupyter Notebook\r\n等交互环境结合，实现交互式缩放、平移等操作。</li>\r\n</ul>\r\n<p><strong>简单示例：</strong> 使用 Matplotlib\r\n绘制一个简单的折线图：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例数据</span></span><br><span class=\"line\">years = [<span class=\"number\">2018</span>, <span class=\"number\">2019</span>, <span class=\"number\">2020</span>, <span class=\"number\">2021</span>, <span class=\"number\">2022</span>]</span><br><span class=\"line\">sales = [<span class=\"number\">150</span>, <span class=\"number\">200</span>, <span class=\"number\">250</span>, <span class=\"number\">220</span>, <span class=\"number\">300</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 绘制折线图</span></span><br><span class=\"line\">plt.plot(years, sales, marker=<span class=\"string\">&#x27;o&#x27;</span>)</span><br><span class=\"line\">plt.title(<span class=\"string\">&quot;Annual Sales&quot;</span>)         <span class=\"comment\"># 添加标题</span></span><br><span class=\"line\">plt.xlabel(<span class=\"string\">&quot;Year&quot;</span>)                <span class=\"comment\"># 添加X轴标签</span></span><br><span class=\"line\">plt.ylabel(<span class=\"string\">&quot;Sales (Thousands)&quot;</span>)   <span class=\"comment\"># 添加Y轴标签</span></span><br><span class=\"line\">plt.grid(<span class=\"literal\">True</span>)                    <span class=\"comment\"># 添加网格线</span></span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p>上述代码绘制了某企业年度销售额的折线趋势图，并加上了标记点、标题和坐标轴标签等。Matplotlib\r\n的 <code>pyplot</code> 接口使这一系列命令式的绘图操作非常直观。</p>\r\n<h3 id=\"seaborn高级统计图表绘制\">Seaborn：高级统计图表绘制</h3>\r\n<p>Seaborn 是建立在 Matplotlib\r\n之上的数据可视化库，提供更高级别的接口来绘制美观的统计图形。相较于\r\nMatplotlib，Seaborn\r\n内置了更多面向数据分析的绘图功能和默认优化的主题风格，使用户无需过多调整就能得到信息丰富且美观的图表。尤其在绘制统计类图表（如分类数据的分布、回归拟合线等）时，Seaborn\r\n能用一行代码完成 Matplotlib 需要多步才能实现的功能。</p>\r\n<p><strong>主要功能特色：</strong></p>\r\n<ul>\r\n<li><strong>美观的默认样式：</strong> Seaborn\r\n默认使用柔和的调色板和网格背景，美观且专业，省去了手动设置样式的工作。<br />\r\n</li>\r\n<li><strong>简化的高级绘图函数：</strong> 提供诸如\r\n<code>scatterplot</code>（散点图）、<code>barplot</code>（柱状图）、<code>histplot</code>（直方图）、<code>heatmap</code>（热力图）、<code>pairplot</code>（成对关系图）等高级函数，可一键绘制带统计元素的图表。例如\r\n<code>sns.regplot</code>\r\n可在散点图上自动添加回归拟合直线和置信区间。<br />\r\n</li>\r\n<li><strong>融合数据处理与可视化：</strong> 大多数 Seaborn\r\n接口允许直接传入 Pandas DataFrame，并指定数据列名，Seaborn\r\n会自动完成数据的抽取和聚合。这让绘图代码更加简洁易读。<br />\r\n</li>\r\n<li><strong>与 Matplotlib 兼容：</strong> Seaborn 绘图返回的对象实际上是\r\nMatplotlib Axes 对象，因此可以继续使用 Matplotlib\r\n的命令对图像进行细节调整，实现两者的无缝协作。</li>\r\n</ul>\r\n<p><strong>简单示例：</strong> 使用 Seaborn\r\n绘制带有分类颜色的散点图：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> seaborn <span class=\"keyword\">as</span> sns</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 加载内置的 Iris 鸡尾酒花数据集</span></span><br><span class=\"line\">iris = sns.load_dataset(<span class=\"string\">&quot;iris&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 绘制散点图，根据物种不同显示不同颜色</span></span><br><span class=\"line\">sns.scatterplot(x=<span class=\"string\">&quot;sepal_length&quot;</span>, y=<span class=\"string\">&quot;sepal_width&quot;</span>, hue=<span class=\"string\">&quot;species&quot;</span>, data=iris)</span><br><span class=\"line\">plt.title(<span class=\"string\">&quot;Iris Sepal Length vs Width&quot;</span>)  <span class=\"comment\"># 添加标题</span></span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p>以上代码利用 Seaborn 的 <code>scatterplot</code> 函数，对 Iris\r\n数据集中萼片长度和宽度进行散点图绘制，并用不同颜色区分花的类别。可以看到，不需要手工处理数据子集或图例，Seaborn\r\n自动完成了这些工作。对于常见的数据可视化任务，Seaborn\r\n能极大提高绘图的便利性和美观度。</p>\r\n<h2\r\nid=\"scikit-learn机器学习与预处理\">Scikit-learn：机器学习与预处理</h2>\r\n<p>Scikit-learn 是 Python\r\n生态中最流行的<strong>机器学习库</strong>之一，提供了丰富的机器学习算法和数据预处理工具。其宗旨是提供<strong>简单高效的预测数据分析工具</strong>，让各类用户都能方便地将其应用于不同场景。Scikit-learn\r\n建立在 NumPy、SciPy 和 Matplotlib\r\n之上，涵盖了从数据预处理、特征工程到各种监督/无监督学习算法的实现，并具有统一的API接口（拟合<code>fit</code>、预测<code>predict</code>、评分<code>score</code>等），易于上手。</p>\r\n<p><strong>主要功能和模块：</strong></p>\r\n<ul>\r\n<li><strong>数据预处理：</strong> 提供标准化/归一化\r\n(<code>StandardScaler</code>)、缺失值填补、编码分类变量\r\n(<code>OneHotEncoder</code>)、特征降维（PCA\r\n等）、特征选择等工具，可以通过流水线 (<code>Pipeline</code>)\r\n将多个预处理步骤和模型串联。<br />\r\n</li>\r\n<li><strong>监督学习算法：</strong>\r\n包括常用的回归（线性回归、岭回归等）、分类（逻辑回归、支持向量机、决策树、随机森林等）算法，以及评估指标和交叉验证方法，方便快速构建和评估模型。<br />\r\n</li>\r\n<li><strong>无监督学习算法：</strong>\r\n提供聚类（K-Means、层次聚类、DBSCAN\r\n等）、降维（PCA、TSNE）和密度估计等方法，帮助探索数据内在结构。<br />\r\n</li>\r\n<li><strong>模型选择与评估：</strong> 提供网格搜索\r\n(<code>GridSearchCV</code>)、随机搜索、交叉验证\r\n(<code>cross_val_score</code>)\r\n等功能以优化模型超参数，并内置大量评估指标来衡量模型性能。<br />\r\n</li>\r\n<li><strong>易用的一致性接口：</strong> 所有模型均采用统一的调用接口：先\r\n<code>fit(X, y)</code> 训练模型，然后 <code>predict(X_new)</code>\r\n进行预测，必要时用 <code>transform</code> 方法处理数据或用\r\n<code>score</code>\r\n评估模型。这种一致性降低了学习成本，也便于切换不同算法进行对比实验=。</li>\r\n</ul>\r\n<p><strong>简单示例：</strong> 使用 Scikit-learn\r\n进行一个简单的回归模型训练和预测：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn.linear_model <span class=\"keyword\">import</span> LinearRegression</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 准备简单的训练数据 (X 为单特征输入，y 为目标输出)</span></span><br><span class=\"line\">X = np.array([[<span class=\"number\">1</span>], [<span class=\"number\">2</span>], [<span class=\"number\">3</span>], [<span class=\"number\">4</span>], [<span class=\"number\">5</span>]])   <span class=\"comment\"># 5个样本，每个只有1个特征</span></span><br><span class=\"line\">y = np.array([<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>])            <span class=\"comment\"># 假设真实关系为 y = 2*x + 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 初始化并训练线性回归模型</span></span><br><span class=\"line\">model = LinearRegression()</span><br><span class=\"line\">model.fit(X, y)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出训练得到的模型参数（截距和系数）</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(model.intercept_, model.coef_)  </span><br><span class=\"line\"><span class=\"comment\"># 输出: 1.0 [2.0] （截距约为1，系数约为2，吻合y=2*x+1的真值）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 用训练好的模型进行预测</span></span><br><span class=\"line\">X_new = np.array([[<span class=\"number\">6</span>]])</span><br><span class=\"line\">y_pred = model.predict(X_new)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(y_pred)  <span class=\"comment\"># 预测当x=6时的y值, 输出: [13.]</span></span><br></pre></td></tr></table></figure>\r\n<p>在这个例子中，我们使用 <code>LinearRegression</code>\r\n来拟合一个简单的一元线性模型。可以看到，Scikit-learn\r\n的使用流程相当简洁：创建模型实例，调用 <code>fit</code>\r\n方法训练，然后使用 <code>predict</code> 进行预测。Scikit-learn\r\n内还包含了许多其他模型和工具，使用方式都遵循类似的接口规范，使其非常易于上手和实践。</p>\r\n<h2 id=\"其他值得关注的库\">其他值得关注的库</h2>\r\n<p>除了上述主要库外，Python\r\n数据生态中还有一些<strong>特定场景下非常有用的库</strong>值得了解。在处理超大规模数据、提升性能或进行统计建模等方面，这些库提供了专门的支持。下面介绍其中几种：</p>\r\n<h3 id=\"dask大数据并行计算\">Dask：大数据并行计算</h3>\r\n<p>当数据量太大以至于无法在单台机器内存中完整处理时，Dask\r\n是一个强大的工具。<strong>Dask\r\n提供高级并行计算能力</strong>，能够让我们熟悉的 Pandas、NumPy\r\n等工具在大数据上以分布式方式运行并获得高性能。简单来说，Dask 可以看作是\r\n<em>“会并行的 Pandas/NumPy”</em>：它提供了与 Pandas、NumPy\r\n接口类似的并行化数据结构（如 Dask DataFrame、Dask\r\nArray），在后台将任务拆分为多个子任务并利用多核CPU甚至集群并行执行。通过\r\nDask，用户无需改动太多代码，就能将单机上的数据处理扩展到大数据集。</p>\r\n<p><strong>主要应用场景和特点：</strong></p>\r\n<ul>\r\n<li><strong>大数据处理：</strong> 可处理比内存大得多的数据集。Dask\r\nDataFrame 的API与 Pandas DataFrame\r\n非常相似，但底层将数据分块存储并按需调度计算，因此即使数据无法全部装入内存也能进行分析。<br />\r\n</li>\r\n<li><strong>并行/分布式计算：</strong> Dask\r\n可以在多核本地环境并行执行，也可以扩展到多机器集群（与诸如 Hadoop 或\r\nSpark 集成），利用集群资源加速计算。<br />\r\n</li>\r\n<li><strong>与现有库集成：</strong> Dask 针对\r\nNumPy、Pandas、Scikit-learn\r\n等都有对应的并行实现版本或兼容接口。例如可以使用 Dask Array\r\n进行大规模数值计算，用 Dask-ML 与 Scikit-learn\r\n接口兼容地训练模型。<br />\r\n</li>\r\n<li><strong>延迟计算模型：</strong> Dask 采用 Lazy\r\nEvaluation（惰性计算），对计算任务构建有向无环图（DAG），只有在需要获取结果时（调用\r\n<code>.compute()</code>）才真正执行。这避免了不必要的中间计算，提升效率。</li>\r\n</ul>\r\n<p><strong>简单示例：</strong> 使用 Dask 处理大数据集（代码与 Pandas\r\n十分相似）：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> dask.dataframe <span class=\"keyword\">as</span> dd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 假设有一个大型 CSV 文件，使用 Dask 读入</span></span><br><span class=\"line\">df = dd.read_csv(<span class=\"string\">&#x27;huge_data.csv&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 像 Pandas 一样对数据进行操作（此时并未真正计算）</span></span><br><span class=\"line\">result = df[df[<span class=\"string\">&quot;columnA&quot;</span>] &gt; <span class=\"number\">0</span>].groupby(<span class=\"string\">&quot;category&quot;</span>).columnB.mean()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 触发实际计算并获取结果（可能利用多核并行执行）</span></span><br><span class=\"line\">result = result.compute()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(result.head())</span><br></pre></td></tr></table></figure>\r\n<p>在这个例子中，我们用 Dask 读取一个超大的 CSV\r\n文件，然后进行过滤和分组聚合的操作。由于 Dask\r\n采<strong>用惰性计算</strong>，在调用 <code>compute()</code>\r\n之前，这些操作并不会立即执行，而是建立起任务计划。当调用\r\n<code>compute</code> 时，Dask\r\n会智能地并行计算各分块的结果并合并。这种方式让我们以类似 Pandas\r\n的代码来处理无法直接装入内存的数据集，在需要时再取回计算结果。</p>\r\n<h3 id=\"polars新兴的高性能-dataframe-库\">Polars：新兴的高性能 DataFrame\r\n库</h3>\r\n<p>Polars 是近年兴起的<strong>高性能 DataFrame\r\n库</strong>，以性能和易用性著称。它使用 Rust 实现核心，引擎采用 Apache\r\nArrow\r\n列式内存格式，充分利用多线程和向量化提升数据处理速度。据官方介绍，Polars\r\n在单机单进程下的许多数据操作性能上远超\r\nPandas，达到了“闪电般快速”的级别。Polars 提供 Python 接口，其 API 与\r\nPandas 类似但有所扩展（例如支持 Lazy Query 惰性计算模式），方便 Pandas\r\n用户上手。对于处理数百万到数亿行数据且追求极致性能的场景，Polars\r\n是一个值得尝试的工具。</p>\r\n<p><strong>主要功能和特点：</strong></p>\r\n<ul>\r\n<li><strong>极速性能：</strong> 核心使用 Rust\r\n实现，多线程查询引擎配合列式存储和 SIMD\r\n向量化，大幅提升数据处理速度。在一些基准测试中，Polars\r\n对常见数据操作的性能可以比 Pandas 快数十倍。<br />\r\n</li>\r\n<li><strong>Pandas 式接口：</strong> 提供易于使用的 API，例如\r\n<code>pl.DataFrame</code>、<code>pl.Series</code>\r\n对象和常用的筛选、聚合、连接等操作，与 Pandas 十分类似。但是 Polars\r\n的表达式系统更强大灵活，支持链式调用和更复杂的计算逻辑。<br />\r\n</li>\r\n<li><strong>Lazy 模式：</strong> Polars 可以选择使用惰性计算（Lazy\r\nAPI），延迟执行一连串的数据操作并由引擎统一优化执行计划，从而避免中间过程的重复扫描，提高整体效率。对于复杂的多步数据处理管道，惰性执行能够自动优化查询顺序。<br />\r\n</li>\r\n<li><strong>内存高效：</strong> 借助 Apache Arrow 格式，Polars\r\n对内存的使用更加紧凑高效，并且可以零拷贝地与其他支持 Arrow\r\n的系统交换数据。</li>\r\n</ul>\r\n<p><strong>简单示例：</strong> 使用 Polars 进行数据过滤和聚合：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> polars <span class=\"keyword\">as</span> pl</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建一个 Polars DataFrame</span></span><br><span class=\"line\">df = pl.DataFrame(&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;city&quot;</span>: [<span class=\"string\">&quot;London&quot;</span>, <span class=\"string\">&quot;Paris&quot;</span>, <span class=\"string\">&quot;London&quot;</span>, <span class=\"string\">&quot;New York&quot;</span>, <span class=\"string\">&quot;Paris&quot;</span>],</span><br><span class=\"line\">    <span class=\"string\">&quot;sales&quot;</span>: [<span class=\"number\">100</span>, <span class=\"number\">150</span>, <span class=\"number\">200</span>, <span class=\"number\">130</span>, <span class=\"number\">170</span>]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 筛选 sales 大于 150 的记录，并按城市分组计算销售额总和</span></span><br><span class=\"line\">filtered = df.<span class=\"built_in\">filter</span>(pl.col(<span class=\"string\">&quot;sales&quot;</span>) &gt; <span class=\"number\">150</span>)</span><br><span class=\"line\">result = filtered.groupby(<span class=\"string\">&quot;city&quot;</span>).agg(pl.col(<span class=\"string\">&quot;sales&quot;</span>).<span class=\"built_in\">sum</span>().alias(<span class=\"string\">&quot;total_sales&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(result)</span><br><span class=\"line\"><span class=\"comment\"># 输出:</span></span><br><span class=\"line\"><span class=\"comment\"># shape: (2, 2)</span></span><br><span class=\"line\"><span class=\"comment\"># ┌──────────┬────────────┐</span></span><br><span class=\"line\"><span class=\"comment\"># │ city     ┆ total_sales│</span></span><br><span class=\"line\"><span class=\"comment\"># │ ---      ┆ ---        │</span></span><br><span class=\"line\"><span class=\"comment\"># │ str      ┆ i64        │</span></span><br><span class=\"line\"><span class=\"comment\"># ╞══════════╪════════════╡</span></span><br><span class=\"line\"><span class=\"comment\"># │ London   ┆ 200        │</span></span><br><span class=\"line\"><span class=\"comment\"># │ Paris    ┆ 170        │</span></span><br><span class=\"line\"><span class=\"comment\"># └──────────┴────────────┘</span></span><br></pre></td></tr></table></figure>\r\n<p>这个示例中，我们创建了一个 Polars 的 DataFrame，过滤出销售额大于 150\r\n的记录，然后按城市汇总销售总和。可以看到，Polars 使用\r\n<code>filter</code>、<code>groupby</code>、<code>agg</code>\r\n等方法完成这些操作，语法上与 Pandas 相似但更加链式。Polars\r\n的执行非常快，特别适合处理大型数据集或对性能要求严苛的情形。</p>\r\n<h3\r\nid=\"statsmodels统计建模与计量经济学\">Statsmodels：统计建模与计量经济学</h3>\r\n<p>Statsmodels 是 Python\r\n中专门用于<strong>统计建模和计量经济分析</strong>的库。它提供大量经典统计模型的实现以及健全的统计检验功能，包括线性回归（含\r\nOLS、GLS）、广义线性模型、时间序列分析（ARIMA、VAR\r\n等）、面板数据模型、生存分析等。此外，Statsmodels\r\n注重提供丰富的统计量和诊断结果，如标准误、p值、置信区间、假设检验等，这使其成为从事学术研究或需要严格统计推断的分析师的利器。简单来说，Statsmodels\r\n对 SciPy 的统计功能做了有益的补充——如果说 Scikit-learn\r\n偏重预测模型的准确性，Statsmodels 则更注重模型的统计解释和推断。</p>\r\n<p><strong>主要功能和特点：</strong></p>\r\n<ul>\r\n<li><strong>丰富的统计模型库：</strong>\r\n提供经典且成熟的统计建模工具，如线性回归（OLS）、逻辑回归、时间序列\r\nARIMA/GARCH、面板数据模型、混合效应模型等。这让 Python\r\n用户可以完成许多以前需要在 R 等统计软件中才能方便进行的建模任务。<br />\r\n</li>\r\n<li><strong>统计检验与诊断：</strong>\r\n内置大量统计检验函数，包括假设检验（t检验、卡方检验等）、模型诊断（如异方差检验、多重共线性检测）、分布拟合检验等，帮助评估数据特征和模型假定。<br />\r\n</li>\r\n<li><strong>结果解读方便：</strong> 对于拟合的模型，Statsmodels\r\n提供包含详细统计结果的 <code>Summary</code>\r\n表格输出，包括系数估计、标准误差、t统计量、p值、置信区间等，从而方便地解读模型显著性和拟合优度。<br />\r\n</li>\r\n<li><strong>公式接口：</strong> 支持 R 语言风格的公式接口，通过\r\n<code>statsmodels.formula.api</code>，用户可以用类似\r\n<code>\"Y ~ X1 + X2\"</code>\r\n的字符串公式来定义模型，这对熟悉统计学公式表示的人来说非常直观便利。</li>\r\n</ul>\r\n<p><strong>简单示例：</strong> 使用 Statsmodels\r\n进行线性回归并获得统计结果：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> statsmodels.api <span class=\"keyword\">as</span> sm</span><br><span class=\"line\"><span class=\"keyword\">import</span> statsmodels.formula.api <span class=\"keyword\">as</span> smf</span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构造一个示例数据集</span></span><br><span class=\"line\">data = pd.DataFrame(&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;sales&quot;</span>:  [<span class=\"number\">100</span>, <span class=\"number\">120</span>, <span class=\"number\">130</span>, <span class=\"number\">150</span>, <span class=\"number\">170</span>, <span class=\"number\">180</span>],   <span class=\"comment\"># 销售额</span></span><br><span class=\"line\">    <span class=\"string\">&quot;budget&quot;</span>: [<span class=\"number\">10</span>,  <span class=\"number\">15</span>,  <span class=\"number\">14</span>,  <span class=\"number\">20</span>,  <span class=\"number\">25</span>,  <span class=\"number\">30</span>]     <span class=\"comment\"># 市场预算</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\"># 使用公式接口进行普通最小二乘回归: sales ~ budget</span></span><br><span class=\"line\">model = smf.ols(<span class=\"string\">&quot;sales ~ budget&quot;</span>, data=data).fit()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出模型回归结果摘要</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(model.summary())</span><br></pre></td></tr></table></figure>\r\n<p>运行上述代码，将会打印出回归模型的详细结果摘要，包括截距和预算系数的估计值、标准误、t\r\n值、p 值，以及模型的 <span class=\"math inline\">\\(R^2\\)</span>、调整\r\n<span class=\"math inline\">\\(R^2\\)</span>\r\n等统计指标。例如，若输出显示预算系数的 p 值远小于\r\n0.05，则表示市场预算对销售额有显著的线性影响。在这个例子中，我们借助\r\nStatsmodels\r\n的公式接口用一行代码完成了回归模型的拟合，<code>summary()</code>\r\n方法则自动生成了专业的统计报告。对于需要深入统计推断和模型诊断的任务，Statsmodels\r\n提供了比 Scikit-learn 更完善的支持。</p>\r\n<h2 id=\"小结合理搭配使用数据处理库\">小结：合理搭配使用数据处理库</h2>\r\n<p>Python 拥有如此丰富的\r\n数据处理库，使得我们在不同阶段可以选用最适合的工具完成任务。在实践中，这些库并非孤立使用，而是经常<strong>协同工作</strong>，形成完整的数据处理流程：</p>\r\n<ul>\r\n<li><strong>NumPy 与底层计算：</strong> NumPy\r\n作为底层，几乎在所有数值计算中都会用到。对于需要进行矩阵运算或自定义算法的步骤，可直接使用\r\nNumPy 以获得最高的性能和控制力。它也为其他高级库提供了基础的数据结构（如\r\nPandas 和 Scikit-learn 都依赖 NumPy 数组作为底层实现）。<br />\r\n</li>\r\n<li><strong>Pandas 作为数据处理中枢：</strong>\r\n在读取数据、清洗整理到特征工程这整个过程中，Pandas\r\n往往是主力。对于结构化的表格数据，Pandas\r\n提供了便利的操作来变换数据格式、处理缺失值、计算统计量。整理好的\r\nDataFrame 可无缝对接后续步骤，例如传递给可视化函数或机器学习模型。<br />\r\n</li>\r\n<li><strong>可视化：Matplotlib 搭配 Seaborn：</strong>\r\n绘制探索性图表时，可以优先使用 Seaborn\r\n迅速生成高层次的统计图形，比如观察数据分布或变量间关系；在需要精细定制图表外观时，再使用\r\nMatplotlib\r\n提供的底层接口做调整。两者结合能够既快速产出结果，又满足美观和定制需求。<br />\r\n</li>\r\n<li><strong>机器学习：Scikit-learn 与预处理：</strong>\r\n当进入建模阶段，Scikit-learn\r\n提供了从数据预处理（标准化、编码等）到模型训练、评估的一站式解决方案。可将\r\nPandas 中整理好的特征数据提取为 NumPy 数组（或直接用 DataFrame），交由\r\nScikit-learn\r\n进行模型训练。训练过程中，如需进行参数调优、模型比较等，Scikit-learn\r\n的工具箱也一应俱全。对于需要统计检验或详细模型解释的情况，可引入\r\nStatsmodels 辅助分析，两者并不冲突：例如先用 Statsmodels\r\n检查变量显著性，再用 Scikit-learn 做预测模型。<br />\r\n</li>\r\n<li><strong>性能与大数据：Dask 和 Polars 加持：</strong>\r\n如果面临数据量特别大或 Pandas 运算速度无法满足的情况，可以考虑引入 Dask\r\n或 Polars。例如，当数据无法全部载入内存时，用 Dask DataFrame 代替\r\nPandas，可以几乎不改变代码就实现对大数据的并行处理=。如果是在单机环境下希望加速计算，Polars\r\n则是很好的替代方案，它的接口与 Pandas\r\n类似但效率更高。当任务完成后，结果仍可转回 Pandas DataFrame 或 NumPy\r\n数组，方便后续继续使用常规的库进行处理或可视化。</li>\r\n</ul>\r\n<p>总而言之，<strong>没有一种库能包揽全部任务</strong>，熟练的数据从业者会根据具体需求组合使用这些工具。NumPy\r\n和 Pandas 是底层数据操作与分析的基石；Matplotlib 与 Seaborn\r\n为结果呈现提供了窗口；Scikit-learn 和 Statsmodels\r\n则一个侧重预测、一个侧重推断，满足不同的建模需求；而 Dask、Polars\r\n等则为大数据和高性能场景保驾护航。随着数据规模和复杂度的增长，合理选择和搭配这些库，能够让我们的数据处理流程既高效又稳健，在探索数据奥秘的道路上走得更快更远。=</p>\r\n","feature":true,"text":"引言 在数据科学、数据工程和数据分析领域，数据处理是必不可少的基础环节。业界常说数据科学家将大部分时间花在整理清洗数据上，有经验的分析师都深知这一点：整个数据分...","permalink":"/post/python-libraries","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"算法","slug":"算法","count":2,"path":"api/categories/算法.json"}],"tags":[{"name":"python","slug":"python","count":2,"path":"api/tags/python.json"},{"name":"数据处理","slug":"数据处理","count":1,"path":"api/tags/数据处理.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E8%A8%80\"><span class=\"toc-text\">引言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#numpy%E9%AB%98%E6%80%A7%E8%83%BD%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80%E5%BA%93\"><span class=\"toc-text\">NumPy：高性能数值计算基础库</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#pandas%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90\"><span class=\"toc-text\">Pandas：结构化数据处理与分析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96matplotlib-%E4%B8%8E-seaborn\"><span class=\"toc-text\">数据可视化：Matplotlib 与\r\nSeaborn</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#matplotlib%E5%BC%BA%E5%A4%A7%E7%9A%84%E7%BB%98%E5%9B%BE%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">Matplotlib：强大的绘图功能</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#seaborn%E9%AB%98%E7%BA%A7%E7%BB%9F%E8%AE%A1%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6\"><span class=\"toc-text\">Seaborn：高级统计图表绘制</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#scikit-learn%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86\"><span class=\"toc-text\">Scikit-learn：机器学习与预处理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96%E5%80%BC%E5%BE%97%E5%85%B3%E6%B3%A8%E7%9A%84%E5%BA%93\"><span class=\"toc-text\">其他值得关注的库</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#dask%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97\"><span class=\"toc-text\">Dask：大数据并行计算</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#polars%E6%96%B0%E5%85%B4%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD-dataframe-%E5%BA%93\"><span class=\"toc-text\">Polars：新兴的高性能 DataFrame\r\n库</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#statsmodels%E7%BB%9F%E8%AE%A1%E5%BB%BA%E6%A8%A1%E4%B8%8E%E8%AE%A1%E9%87%8F%E7%BB%8F%E6%B5%8E%E5%AD%A6\"><span class=\"toc-text\">Statsmodels：统计建模与计量经济学</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93%E5%90%88%E7%90%86%E6%90%AD%E9%85%8D%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%BA%93\"><span class=\"toc-text\">小结：合理搭配使用数据处理库</span></a></li></ol>","author":{"name":"Rockway","slug":"blog-author","avatar":"https://lingmafuture.github.io/images/3.jpg","link":"https://lingmafuture.github.io","description":"一个充满情怀的AI技术探索者，欢迎交流人工智能、量化交易、科技产品、创业灵感。","socials":{"github":"https://github.com/lingmafuture","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Hexo Aurora 主题 LaTeX 数学公式渲染完整配置指南","uid":"cdaf287798a8886aaed8d059a065cece","slug":"hexo-mathjax","date":"2025-08-16T16:00:00.000Z","updated":"2025-08-19T13:07:27.610Z","comments":true,"path":"api/articles/hexo-mathjax.json","keywords":"blog, technology, programming","cover":"images/hexo-aurora-mathjax-guide.png","text":"解决Aurora主题LaTeX公式渲染问题的完整配置指南，包含技术栈选择、转义规则修复和实际测试验证。...","permalink":"/post/hexo-mathjax","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"建站","slug":"建站","count":2,"path":"api/categories/建站.json"}],"tags":[{"name":"hexo","slug":"hexo","count":2,"path":"api/tags/hexo.json"},{"name":"教程","slug":"教程","count":2,"path":"api/tags/教程.json"}],"author":{"name":"Rockway","slug":"blog-author","avatar":"https://lingmafuture.github.io/images/3.jpg","link":"https://lingmafuture.github.io","description":"一个充满情怀的AI技术探索者，欢迎交流人工智能、量化交易、科技产品、创业灵感。","socials":{"github":"https://github.com/lingmafuture","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Transformer 架构详解（含 PyTorch 代码）","uid":"48a8ab6165265f9c75721ce750feca94","slug":"transformer","date":"2025-08-12T16:00:00.000Z","updated":"2025-08-23T01:50:17.699Z","comments":true,"path":"api/articles/transformer.json","keywords":"blog, technology, programming","cover":"images/transformer.png","text":"读者对象：已具备基本深度学习与 PyTorch 基础，希望系统掌握 Transformer 各模块设计与实现的工程师/学生。 文章目标：从实现角度深入讲清楚每个...","permalink":"/post/transformer","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"人工智能","slug":"人工智能","count":3,"path":"api/categories/人工智能.json"}],"tags":[{"name":"transformer","slug":"transformer","count":1,"path":"api/tags/transformer.json"}],"author":{"name":"Rockway","slug":"blog-author","avatar":"https://lingmafuture.github.io/images/3.jpg","link":"https://lingmafuture.github.io","description":"一个充满情怀的AI技术探索者，欢迎交流人工智能、量化交易、科技产品、创业灵感。","socials":{"github":"https://github.com/lingmafuture","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}